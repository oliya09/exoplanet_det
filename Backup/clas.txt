import numpy as np
import pickle
import os
import tensorflow as tf
from sklearn.ensemble import RandomForestClassifier
from .lightcurve import get_lightcurve_and_bls
from .utils import odd_even_test, secondary_eclipse_test, create_transit_mask, centroid_check
from .catalog import get_rv_k, get_hostname_from_tic

CNN_MODEL_PATH = 'cnn_model.h5'
RF_MODEL_PATH = 'rf_model.pkl'

class HybridClassifier:
    def __init__(self):
        self.cnn_model = tf.keras.models.load_model(CNN_MODEL_PATH) if os.path.exists(CNN_MODEL_PATH) else None
        if os.path.exists(RF_MODEL_PATH):
            with open(RF_MODEL_PATH, 'rb') as f:
                self.rf_model = pickle.load(f)
        else:
            self.rf_model = RandomForestClassifier(n_estimators=50, random_state=42)
    
    def ml_score(self, flux):
        """Гибрид CNN + RF"""
        flux = flux[:2000]  # Стандарт length
        if len(flux) < 2000:
            flux = np.pad(flux, (0, 2000 - len(flux)), mode='constant')
        
        if self.cnn_model is None:
            features = flux.reshape(1, -1)
            return self.rf_model.predict_proba(features)[0, 1]
        
        flux_cnn = flux.reshape(1, 2000, 1)
        cnn_pred = self.cnn_model.predict(flux_cnn, verbose=0)[0][0]
        rf_features = flux.reshape(1, -1)
        rf_pred = self.rf_model.predict_proba(rf_features)[0][1]
        
        ml_score = 0.6 * cnn_pred + 0.4 * rf_pred
        return ml_score
    
    def extract_features(self, lc, period, t0, duration, depth):
        time, flux = lc.time.value, lc.flux.value
        flux_rms = np.std(flux)
        phases = ((time - t0) % period) / period
        
        odd_depth = np.min(flux[phases < 0.5]) if np.any(phases < 0.5) else depth
        even_depth = np.min(flux[phases >= 0.5]) if np.any(phases >= 0.5) else depth
        odd_even_diff = abs(odd_depth - even_depth) / depth if depth > 0 else 0
        
        sec_mask = np.abs(phases - 0.5) < (duration / period)
        secondary_depth = abs(np.min(flux[sec_mask]) - 1) if np.any(sec_mask) else 0
        
        centroid_var = np.var(flux) / np.mean(flux)
        
        features = [depth, period, duration, flux_rms, odd_even_diff, secondary_depth, centroid_var]
        return np.array(features), flux  # features для classical, flux для ML

    def classical_scores(self, lc, period, t0, duration, depth):
        time, flux = lc.time.value, lc.flux.value
        odd_even_flag = odd_even_test(time, flux, period, t0, duration)
        sec_drop, prim_drop = secondary_eclipse_test(time, flux, period, t0, duration)
        centroid_flag = centroid_check(None, create_transit_mask(time, period, t0, duration))
        hostname = get_hostname_from_tic("TIC_placeholder")  # Stub
        rv_amp = get_rv_k(hostname) or 100.0
        
        odd_even_score = 1.0 if odd_even_flag == "consistent" else 0.0
        secondary_score = 1.0 if sec_drop < 0.5 * prim_drop else 0.0
        centroid_score = 1.0 if centroid_flag == "ok" else 0.0
        depth_score = 1.0 if depth < 0.03 else 0.0
        rv_score = 1.0 if rv_amp < 200 else 0.0
        
        return {
            'odd_even': odd_even_flag, 'odd_even_score': odd_even_score,
            'secondary': 'weak' if secondary_score else 'strong', 'secondary_score': secondary_score,
            'centroid': centroid_flag, 'centroid_score': centroid_score,
            'depth': 'reasonable' if depth_score else 'too_large', 'depth_score': depth_score,
            'rv': 'ok' if rv_score else 'high', 'rv_score': rv_score
        }

def classify_target_full(target_id, lc, period, t0, duration, depth, mission="TESS"):
    """
    Классифицирует объект по транзитной кривой (гибрид ML + checks).
    """
    if lc is None:
        return {"ID": target_id, "Status": "No Data", "Reason": "No LC data", "Score": 0.0, "lc": None}

    classifier = HybridClassifier()
    features, flux = classifier.extract_features(lc, period, t0, duration, depth)
    ml_score = classifier.ml_score(flux)
    
    checks = classifier.classical_scores(lc, period, t0, duration, depth)
    
    # Гибрид: 0.55*ML + 0.15*oe + 0.15*sec + 0.10*cent + 0.05*depth
    hybrid_score = (
        0.55 * ml_score +
        0.15 * checks['odd_even_score'] +
        0.15 * checks['secondary_score'] +
        0.10 * checks['centroid_score'] +
        0.05 * checks['depth_score']
    )
    hybrid_score = max(0.0, min(1.0, hybrid_score))
    
    # Status
    if hybrid_score >= 0.9:
        status, reason = "Confirmed Planet", "High confidence"
    elif checks['secondary_score'] == 0:
        status, reason = "False Positive", "Strong secondary eclipse"
    elif checks['odd_even_score'] == 0:
        status, reason = "False Positive", "Odd/even mismatch"
    elif checks['centroid_score'] == 0:
        status, reason = "False Positive", "Centroid offset"
    elif checks['depth_score'] == 0:
        status, reason = "False Positive", "Unrealistic depth"
    elif hybrid_score < 0.6:
        status, reason = "Likely False Positive", "Low score"
    else:
        status, reason = "Candidate", "Transit detected"
    
    # Explain
    explain_parts = [f"ML: {ml_score:.2f}", f"Odd/even: {checks['odd_even']}", f"Secondary: {checks['secondary']}",
                     f"Centroid: {checks['centroid']}", f"Depth: {checks['depth']}"]
    explain = f"Уверены потому что: {'; '.join(explain_parts)}. Общий score: {hybrid_score:.2f}"
    
    res = {
        "ID": target_id, "Status": status, "Period": period, "Depth": depth,
        "ML_score": round(ml_score, 2), "Hybrid_score": round(hybrid_score, 2),
        "Checks": checks, "Reason": reason, "Explain": explain, "lc": lc
    }
    return res